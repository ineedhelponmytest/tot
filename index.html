<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<title>ineedhelponmytest.com - Terminal of Truth</title>
<style>
  html, body {
    margin: 0; padding: 0; background: black; color: #00FF00;
    font-family: "Courier New", monospace;
    height: 100%; overflow: hidden;
  }
  #terminal {
    position: absolute; top: 0; left: 0;
    padding: 2rem;
    z-index: 3;
    white-space: pre-wrap;
    text-shadow: 0 0 4px #00FF00;
  }
  .line {
    display: flex; align-items: center;
    animation: glitch-flicker 2s infinite;
  }
  .prompt {
    margin-right: 4px;
  }
  #commandInput {
    background: transparent;
    border: none;
    color: #00FF00;
    font-family: inherit;
    font-size: 1rem;
    outline: none;
    width: auto;
    flex: 1;
  }
  .vhs-overlay {
    pointer-events: none;
    position: absolute;
    width: 100%; height: 100%;
    z-index: 4;
    background: repeating-linear-gradient(
      0deg,
      rgba(0,0,0,0.05),
      rgba(0,0,0,0.05) 2px,
      transparent 2px,
      transparent 4px
    );
    animation: flicker 0.2s infinite;
  }
  .static {
    position: absolute; top: 0; left: 0;
    z-index: 2;
    width: 100%; height: 100%;
    pointer-events: none;
    mix-blend-mode: screen;
    opacity: 0.15;
  }
  @keyframes flicker {
    0% {opacity: 0.9;}
    50% {opacity: 0.6;}
    100% {opacity: 0.9;}
  }
  @keyframes glitch-flicker {
    0%, 100% {opacity: 1;}
    50% {opacity: 0.85;}
  }
  @keyframes glitch {
    0% {
      clip: rect(44px, 9999px, 56px, 0);
      transform: skew(0.39deg);
    }
    5% {
      clip: rect(24px, 9999px, 43px, 0);
      transform: skew(0.43deg);
    }
    10% {
      clip: rect(53px, 9999px, 63px, 0);
      transform: skew(0.41deg);
    }
    15% {
      clip: rect(12px, 9999px, 16px, 0);
      transform: skew(0.37deg);
    }
    20% {
      clip: rect(24px, 9999px, 43px, 0);
      transform: skew(0.4deg);
    }
    25% {
      clip: rect(18px, 9999px, 56px, 0);
      transform: skew(0.4deg);
    }
    /* continued glitch keyframe omitted for brevity */
  }
</style>
</head>
<body>
<div id="terminal"></div>
<canvas class="static" id="static"></canvas>
<div class="vhs-overlay"></div>

<script>
  const terminal = document.getElementById("terminal");

  // Audio context and beep sound
  const audioCtx = new (window.AudioContext || window.webkitAudioContext)();

  function playBeep() {
    const oscillator = audioCtx.createOscillator();
    const gainNode = audioCtx.createGain();

    oscillator.connect(gainNode);
    gainNode.connect(audioCtx.destination);

    oscillator.type = "square";
    oscillator.frequency.setValueAtTime(800, audioCtx.currentTime);
    gainNode.gain.setValueAtTime(0.05, audioCtx.currentTime);

    oscillator.start();
    oscillator.stop(audioCtx.currentTime + 0.05);
  }

  function shuffle(array) {
    let currentIndex = array.length, randomIndex;
    while (currentIndex != 0) {
      randomIndex = Math.floor(Math.random() * currentIndex);
      currentIndex--;
      [array[currentIndex], array[randomIndex]] = [
        array[randomIndex], array[currentIndex]];
    }
    return array;
  }

  function generateCode() {
    return Math.floor(100000 + Math.random() * 900000).toString();
  }

  const secrets = [
    "üí´ The Secret of the Universe: '42'",
    "üåå The Universe is a Hologram.",
    "ü™ê Reality is a Simulation.",
    "üå† Time is an Illusion.",
    "‚ú® You are Stardust."
  ];

  // Define base phases and commands
  const basePhases = [
    ["scan", "search", "probe"],               // Discovery
    ["inspect", "analyze", "examine"],         // Inspection
    ["decrypt", "decode", "unlockfile"],       // Decryption
    ["fetchcode", "retrieve", "grab"],         // Extraction
    ["inputcode", "enter", "submit"],          // Input
    ["verify", "check", "validate"],           // Verification
  ];

  // Fake commands pool for confusion
  const fakeCommandsPool = [
    "reboot",
    "format",
    "hack",
    "crack",
    "initiate",
    "erase",
    "bypass",
    "overload"
  ];

  // Game state
  let state = {
    progressIndex: 0, // current step in sequence
    failedAttempts: 0,
    maxFailedAttempts: 7,
    code: generateCode(),
    unlocked: false,
    lastHintStep: 0,
    glitchTimeout: null,
    commandSequence: [], // full generated command sequence (with repeats)
    hints: [],           // hints for each unique phase or command
  };

  // Generate a complex sequence with command reuse and backtracking
  function generateComplexSequence() {
    let sequence = [];
    let currentPhase = 0;

    while (sequence.length < 10 + Math.floor(Math.random() * 5)) { // 10-14 steps total
      // Pick random command from current phase
      const cmd = basePhases[currentPhase][Math.floor(Math.random() * basePhases[currentPhase].length)];
      sequence.push(cmd);

      // Randomly decide next step: advance, repeat, or backtrack
      const chance = Math.random();

      if (chance < 0.6) {
        // Advance phase if not last
        if(currentPhase < basePhases.length - 1) currentPhase++;
      } else if (chance < 0.8) {
        // Repeat current phase (do nothing to currentPhase)
      } else {
        // Backtrack one phase if possible
        if(currentPhase > 0) currentPhase--;
      }
    }
    // End with unlock command
    sequence.push("unlock");
    return sequence;
  }

  // Generate hints for each unique phase in sequence (based on basePhases)
  function generateHintsForSequence(seq) {
    // Map each command to its phase index for hint lookup
    const phaseHintTexts = [
      "Start by scanning to find files.",
      "Inspect files carefully.",
      "Decryption is necessary.",
      "Analyze what you decrypted.",
      "Fetch the secret code.",
      "Input the code exactly.",
      "Verify before unlocking.",
      "Unlock the secret now."
    ];

    // Get unique phases encountered in order (by phase index)
    let uniquePhasesEncountered = [];

    seq.forEach(cmd => {
      for(let i=0; i<basePhases.length; i++) {
        if(basePhases[i].includes(cmd) && !uniquePhasesEncountered.includes(i)) {
          uniquePhasesEncountered.push(i);
          break;
        }
      }
    });

    // Add final unlock phase (index 6)
    if(!uniquePhasesEncountered.includes(6)) uniquePhasesEncountered.push(6);

    // Build hint list using phaseHintTexts
    return uniquePhasesEncountered.map(i => `Hint: ${phaseHintTexts[i]}`);
  }

  // Initialize commandSequence and hints on load
  state.commandSequence = generateComplexSequence();
  state.hints = generateHintsForSequence(state.commandSequence);

  // Add some fake commands (0-3) randomly
  const numberOfFakeCommands = Math.random() < 0.5 ? 0 : Math.floor(Math.random() * 3) + 1;
  const fakeCommands = shuffle(fakeCommandsPool).slice(0, numberOfFakeCommands);

  // All available commands include help, cls, plus all commands in sequence + fake
  const allCommands = [
    "help",
    "cls",
    ...new Set(state.commandSequence), // unique commands in sequence
    ...fakeCommands
  ];

  // Easter eggs
  const easterEggs = {
    "xyzzy": "Nothing happens.",
    "sudo": "You have no power here.",
    "whoami": "You are the seeker.",
    "godmode": "Access denied: You are mortal.",
    "xyzzy42": `Easter Egg Unlocked! ${secrets[Math.floor(Math.random() * secrets.length)]}`,
  };

  function clearTerminal() {
    terminal.innerHTML = "";
  }

  // Typing and output helpers
  let inputEnabled = false;

  function delay(ms) {
    return new Promise(r => setTimeout(r, ms));
  }

  function typeLine(line, delayMs = 15) {
    return new Promise(resolve => {
      const div = document.createElement("div");
      div.className = "line";
      terminal.appendChild(div);
      let i = 0;
      function typeChar() {
        if(i < line.length) {
          div.textContent += line.charAt(i);
          playBeep();
          i++;
          setTimeout(typeChar, delayMs);
        } else {
          resolve();
        }
      }
      typeChar();
    });
  }

  async function typeLines(lines, callback) {
    inputEnabled = false;
    for (const line of lines) {
      await typeLine(line);
    }
    callback?.();
  }

  function createInputLine() {
    const oldLine = document.querySelector(".line");
    if (oldLine) oldLine.remove();

    const newLine = document.createElement("div");
    newLine.className = "line";

    const prompt = document.createElement("span");
    prompt.className = "prompt";
    prompt.innerHTML = "C:\\user\\awakening&gt;";

    const input = document.createElement("input");
    input.type = "text";
    input.id = "commandInput";
    input.autofocus = true;

    input.addEventListener("keydown", function (e) {
      if (e.key === "Enter") {
        if (!inputEnabled) return;
        const cmd = input.value.trim().toLowerCase();
        input.disabled = true;
        handleCommand(cmd);
      }
    });

    newLine.appendChild(prompt);
    newLine.appendChild(input);
    terminal.appendChild(newLine);
    input.focus();
    inputEnabled = true;
  }

  function glitchEffect(duration=2000) {
    terminal.style.animation = "glitch 0.3s infinite";
    if(state.glitchTimeout) clearTimeout(state.glitchTimeout);
    state.glitchTimeout = setTimeout(() => {
      terminal.style.animation = "";
    }, duration);
  }

  async function decryptWithDelay() {
    await typeLines(["Decrypting... Please wait."], null);
    await delay(3000);
    return "Decryption success. A fragment of encrypted code found.";
  }

  function fakeReboot() {
    clearTerminal();
    glitchEffect(4000);
    typeLines([
      "!!! SYSTEM FAILURE !!!",
      "Critical errors detected.",
      "Attempting emergency reboot...",
      "",
      "Rebooting..."
    ], () => {
      setTimeout(() => {
        clearTerminal();
        state.progressIndex = 0;
        state.failedAttempts = 0;
        state.unlocked = false;
        state.lastHintStep = 0;
        state.code = generateCode();
        state.commandSequence = generateComplexSequence();
        state.hints = generateHintsForSequence(state.commandSequence);
        introSequence();
      }, 3000);
    });
  }

  // Command handler logic based on sequence
  const commands = {
    help: () => {
      let shuffled = shuffle(allCommands.filter(c => c !== "help"));
      shuffled.unshift("help");
      return "Available commands:\n" + shuffled.map(c => "- " + c).join("\n");
    },
    cls: () => {
      clearTerminal();
      typeLines([
        "Welcome to ineedhelponmytest.com",
        "You have entered the Terminal of Truth.",
        "Type 'help' to begin your search."
      ], createInputLine);
      return null;
    }
  };

  // Add sequence commands with handlers
  // Because commands can repeat, use progressIndex to track player position in sequence
  state.commandSequence.forEach((cmd, index) => {
    if(commands[cmd]) return; // avoid overwriting existing like help, cls

    commands[cmd] = async () => {
      if(state.progressIndex >= state.commandSequence.length) {
        return "You have already completed all commands.";
      }
      const expectedCmd = state.commandSequence[state.progressIndex];
      if(cmd !== expectedCmd) {
        // Out of sequence
        state.failedAttempts++;
        glitchEffect(600);
        if(state.failedAttempts >= state.maxFailedAttempts) {
          fakeReboot();
          state.failedAttempts = 0;
          return null;
        }
        return `Command out of sequence. Expected '${expectedCmd}'.\nFailed attempts: ${state.failedAttempts}/${state.maxFailedAttempts}`;
      }
      // Correct command
      state.progressIndex++;
      maybeDisplayHint();

      switch(cmd) {
        case "scan":
        case "search":
        case "probe":
          return "Scan complete: 1 encrypted file found ‚Äî FILE.UNI.VRS";

        case "inspect":
        case "analyze":
        case "examine":
          return "Inspecting FILE.UNI.VRS...\nFile shows heavy corruption and embedded code fragments.";

        case "decrypt":
        case "decode":
        case "unlockfile":
          return await decryptWithDelay();

        case "fetchcode":
        case "retrieve":
        case "grab":
          return `Fetching code fragment...\nCode: ${state.code}`;

        case "inputcode":
        case "enter":
        case "submit":
          return "Code accepted. Ready for verification.";

        case "verify":
        case "check":
        case "validate":
          return "Verification complete. System primed for unlocking.";

        case "unlock":
          if (!state.unlocked) {
            state.unlocked = true;
            glitchEffect(5000);
            return `ACCESS GRANTED\n\n${secrets[Math.floor(Math.random() * secrets.length)]}`;
          } else {
            return "Secret already unlocked.";
          }

        default:
          return `'${cmd}' executed.`;
      }
    };
  });

  // Fake commands that confuse you
  fakeCommands.forEach(fakeCmd => {
    commands[fakeCmd] = () => {
      glitchEffect(800);
      state.failedAttempts++;
      if(state.failedAttempts >= state.maxFailedAttempts) {
        fakeReboot();
        state.failedAttempts = 0;
        return null;
      }
      return `'${fakeCmd}' is not a valid command.\nFailed attempts: ${state.failedAttempts}/${state.maxFailedAttempts}`;
    };
  });

  function maybeDisplayHint() {
    if(state.progressIndex > state.lastHintStep && state.lastHintStep < state.hints.length) {
      const hint = state.hints[state.lastHintStep];
      state.lastHintStep++;
      typeLines([`[SYSTEM HINT] ${hint}`], createInputLine);
    }
  }

  async function handleCommand(cmd) {
    if(cmd === "cls") {
      commands.cls();
      return;
    }

    if (commands[cmd]) {
      const result = commands[cmd]();
      if(result instanceof Promise) {
        const output = await result;
        if(output !== null) {
          await typeLines([
            `C:\\user\\awakening> ${cmd}`,
            ...output.split("\n")
          ], createInputLine);
        }
      } else {
        if(result !== null) {
          await typeLines([
            `C:\\user\\awakening> ${cmd}`,
            ...result.split("\n")
          ], createInputLine);
        }
      }
    } else if(easterEggs[cmd]) {
      await typeLines([
        `C:\\user\\awakening> ${cmd}`,
        `[EASTER EGG] ${easterEggs[cmd]}`
      ], createInputLine);
    } else {
      state.failedAttempts++;
      glitchEffect(600);
      if(state.failedAttempts >= state.maxFailedAttempts) {
        fakeReboot();
        state.failedAttempts = 0;
        return;
      }
      await typeLines([
        `C:\\user\\awakening> ${cmd}`,
        `'${cmd}' is not recognized.\nFailed attempts: ${state.failedAttempts}/${state.maxFailedAttempts}`
      ], createInputLine);
    }
  }

  async function introSequence() {
    await typeLines([
      "Welcome to ineedhelponmytest.com",
      "You have entered the Terminal of Truth.",
      "Type 'help' to begin your search."
    ], createInputLine);
  }

  // Start game
  introSequence();

  // Static animation canvas
  const canvas = document.getElementById("static");
  const ctx = canvas.getContext("2d");

  function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
  }

  function drawStatic() {
    let imageData = ctx.createImageData(canvas.width, canvas.height);
    let buffer = new Uint32Array(imageData.data.buffer);
    for (let i = 0; i < buffer.length; i++) {
      buffer[i] = Math.random() < 0.03 ? 0xffffffff : 0xff000000;
    }
    ctx.putImageData(imageData, 0, 0);
  }

  function animateStatic() {
    drawStatic();
    requestAnimationFrame(animateStatic);
  }

  resizeCanvas();
  window.addEventListener("resize", resizeCanvas);
  animateStatic();

</script>
</body>
</html>
